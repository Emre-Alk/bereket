class HandleEventJob < ApplicationJob
  queue_as :default

  def perform(event)
    # Here first filter event by 3rd party source (ie, origin like stripe, etc...),
    # to redirect event to the corresponding handler.
    case event.source
    when 'stripe'
      handle_stripe_event(event)
    end
  end

  def handle_stripe_event(event)
    stripe_event = Stripe::Event.construct_from(event.data)

    case stripe_event.type
    when 'customer.created' # test with stripe CLI
      handle_customer_created(stripe_event)
    when 'account.updated'
      handle_account_updated(stripe_event)
    when 'checkout.session.completed'
      handle_checkout_session_completed(stripe_event)
    end
    # when 'capability.updated' # Useful if goal is to create/check financial account as external account
    # handle_capability_updated(stripe_event)
  end

  def handle_checkout_session_completed(stripe_event)
    # retrive checkout session
    checkout_session = Stripe::Checkout::Session.retrieve(
      {
        id: stripe_event.data.object.id,
        expand: [:line_items, 'payment_intent.payment_method']
      }
    )

    if checkout_session.payment_status == 'paid' # create a donation record if status is paid
      # retrieve a place_id
      place = Place.find(checkout_session.metadata.place_id)

      # retrive a donator_id
      if checkout_session.customer_creation
        # case visitor not converted yet (cus created by CS but not a user yet) || user not logged in
        email = checkout_session.customer_details.email
        name = checkout_session.customer_details.name # || checkout_session.customer_details.email

        # this will find already existing visitor or an already registered user that is not logged in
        # or initiate a new one based on email and role
        visitor = User.find_or_initialize_by(
          email:,
          role: 'donator'
        )
        puts '🔵🔵🔵🔵🔵🔵🔵🔵'
        puts visitor.inspect
        puts '🔵🔵🔵🔵🔵🔵🔵🔵'

        if visitor.donator&.visitor? # && visitor.id && visitor.valid_password?('654321') #PS: check by status should suffice
          # case find already existing visitor comingback for 2nd/+ time
          # retrieve his customer id so to updated with the last CS generated customer id
          # So if convert on sucess page, he will save his last donaton only based on CS id and Cus id (in the last CS)
          donator = visitor.donator
          customer = donator.customer
          customer.update!(stripe_id: checkout_session.customer)
          puts '⬜️⬜️⬜️⬜️⬜️⬜️⬜️⬜️'

        elsif visitor.donator&.enrolled? # && visitor.id && !visitor.valid_password?('654321') #PS: check by status should suffice
          # case find already registered user that is not logged in
          donator = visitor.donator
          # in contradiction to what the docs API says, CS cannot be updated
          # /!\/!\/!\
          # So the CS will generate a cus id to a registered donator with already a valid cus id
          # and donation will have a CS id referencing a wrong cus-id
          # which can be ambiguous: donator have a donation where the CS don't reference his cus-id
          # Stripe::Checkout::Session.update(
          #   checkout_session.id,
          #   { metadata: { registered_customer: donator.customer.stripe_id } }
          # )

          puts '🟪🟪🟪🟪🟪🟪🟪🟪'
        else
          # case initialize new visitor (1st visit)
          puts '🟧🟧🟧🟧🟧🟧🟧🟧🟧'
          puts visitor
          puts visitor.id
          puts visitor.first_name
          puts !visitor.valid_password?('654321')
          puts '🟧🟧🟧🟧🟧🟧🟧🟧🟧'

          visitor.password = '654321'
          visitor.first_name = name.split(' ')[0].to_s
          visitor.last_name = name.split(' ')[1].to_s
          visitor.save!

          donator = visitor.donator

          # update the status to visitor
          donator.visitor!

          # retrieve his customer id generated by donator creation to updated with the CS generated customer id
          # So if convert on sucess page, he will save his last donaton only based on CS id and Cus id (in the last CS)
          customer = donator.customer
          customer.update!(stripe_id: checkout_session.customer)
        end

      else
        # case when donator is already registrated and donate 1st time. BC 2nd times are done by PaymentIntent.
        donator = Customer.find_by(stripe_id: checkout_session.customer).donator
        puts '🟨🟨🟨🟨🟨🟨🟨🟨🟨'
      end

      # retrive donated amount
      amount = checkout_session.amount_total
      total_fee = checkout_session.metadata.total_fee
      amount_net = amount - total_fee.to_f

      # create a donation record (donator, place, cs, amount brut, occured_on)
      # /!\/!\/!\/!\/!\/!\
      # if donator is a registered user => no pbm.
      # when donator is a visitor => don't have a donator_id to create donation object, so:
      # For now, I create donation object with a general purpose made-up user account since need a donator_id
      # on success page, if visitor want to convert, I update the donation just created to be associated with his id.
      # but if he don't, I still need the donation to exist for the asso user.
      # So, I keep it as associated to the visitor purpose user id
      # TODO: how to create a donation object even without a registered donator ?

      Donation.create!(
        place:,
        donator:,
        amount:,
        amount_net:,
        occured_on: Date.today,
        checkout_session_id: checkout_session.id
      )

      # for next times, payment intent with cus id and pm id can be done.
      # however, on testing i had to create pi, then "status": "requires_confirmation".
      # so i confirmed via Stripe::PaymentIntent.confirm(), then "status": "succeeded".
      # the money is transfer and my app is paid.
      # in live mode, do i still need to confirm server-side ?
    end
  end

  def handle_capability_updated(stripe_event)
    capability = stripe_event.data.object
    if capability.id == 'transfers' && capability.status == 'active'
      account = Account.find_by(stripe_id: capability.account)
      service = StripeAccount.new(account)
      service.ensure_external_account
    end
  end

  def handle_account_updated(stripe_event)
    stripe_account = stripe_event.data.object
    account = Account.find_by(stripe_id: stripe_account.id)
    deadline = Time.at(stripe_account.requirements.current_deadline).to_datetime

    puts '✅✅✅✅✅✅✅'
    if !stripe_account.requirements.eventually_due.empty? # if eventually_due is not empty
      requirements = 'eventually'
    elsif !stripe_account.requirements.currently_due.empty? # if currently_due is not empty
      requirements = 'currently'
      stripe_deadline = deadline
    elsif !stripe_account.requirements.past_due.empty? # if past_due is not empty
      requirements = 'past'
      stripe_deadline = deadline
    else
      requirements = 'clear'
    end

    status = 'disabled' unless stripe_account.requirements.disabled_reason.empty?

    account.update!(
      charges_enabled: stripe_account.charges_enabled,
      payouts_enabled: stripe_account.payouts_enabled,
      external_bank_account_id: stripe_account.external_accounts.data.first.id,
      last_four: stripe_account.external_accounts.data.first.last4,
      requirements:,
      stripe_deadline:,
      status:,
    )

    puts '✅✅✅✅✅✅✅'

    # stripe_deadline = Time.at(stripe_account.requirements.current_deadline).to_datetime
    # # if eventually_due is not empty
    # account.update!(requirements: 'eventually') unless stripe_account.requirements.eventually_due.empty?

    # # if currently_due is not empty
    # account.update!(requirements: 'currently', stripe_deadline:) unless stripe_account.requirements.currently_due.empty?

    # # if past_due is not empty
    # account.update!(requirements: 'past', stripe_deadline:) unless stripe_account.requirements.past_due.empty?

    # # if account disabled
    # account.update!(status: 'disabled') unless stripe_account.requirements.disabled_reason.empty?
  end

  def handle_customer_created(stripe_event)
    puts '🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢'
    puts "customer created #{stripe_event.data.object.id}"
    puts '🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢'
  end
end
